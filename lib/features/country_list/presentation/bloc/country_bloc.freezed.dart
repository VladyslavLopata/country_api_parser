// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'country_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$CountryEventTearOff {
  const _$CountryEventTearOff();

  InitialCountryEvent init() {
    return const InitialCountryEvent();
  }

  RemoveCountryEvent remove(Country country) {
    return RemoveCountryEvent(
      country,
    );
  }

  SelectedCountryEvent selected(Country country) {
    return SelectedCountryEvent(
      country,
    );
  }

  InputAcceptedCountryEvent inputAccepted(String input) {
    return InputAcceptedCountryEvent(
      input,
    );
  }

  KeyboardInputCountryEvent keyboardInput(String input) {
    return KeyboardInputCountryEvent(
      input,
    );
  }

  KeyboardSubmitCountryEvent keyboardSubmit(String input) {
    return KeyboardSubmitCountryEvent(
      input,
    );
  }
}

/// @nodoc
const $CountryEvent = _$CountryEventTearOff();

/// @nodoc
mixin _$CountryEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Country country) remove,
    required TResult Function(Country country) selected,
    required TResult Function(String input) inputAccepted,
    required TResult Function(String input) keyboardInput,
    required TResult Function(String input) keyboardSubmit,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Country country)? remove,
    TResult Function(Country country)? selected,
    TResult Function(String input)? inputAccepted,
    TResult Function(String input)? keyboardInput,
    TResult Function(String input)? keyboardSubmit,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialCountryEvent value) init,
    required TResult Function(RemoveCountryEvent value) remove,
    required TResult Function(SelectedCountryEvent value) selected,
    required TResult Function(InputAcceptedCountryEvent value) inputAccepted,
    required TResult Function(KeyboardInputCountryEvent value) keyboardInput,
    required TResult Function(KeyboardSubmitCountryEvent value) keyboardSubmit,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialCountryEvent value)? init,
    TResult Function(RemoveCountryEvent value)? remove,
    TResult Function(SelectedCountryEvent value)? selected,
    TResult Function(InputAcceptedCountryEvent value)? inputAccepted,
    TResult Function(KeyboardInputCountryEvent value)? keyboardInput,
    TResult Function(KeyboardSubmitCountryEvent value)? keyboardSubmit,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CountryEventCopyWith<$Res> {
  factory $CountryEventCopyWith(
          CountryEvent value, $Res Function(CountryEvent) then) =
      _$CountryEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$CountryEventCopyWithImpl<$Res> implements $CountryEventCopyWith<$Res> {
  _$CountryEventCopyWithImpl(this._value, this._then);

  final CountryEvent _value;
  // ignore: unused_field
  final $Res Function(CountryEvent) _then;
}

/// @nodoc
abstract class $InitialCountryEventCopyWith<$Res> {
  factory $InitialCountryEventCopyWith(
          InitialCountryEvent value, $Res Function(InitialCountryEvent) then) =
      _$InitialCountryEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitialCountryEventCopyWithImpl<$Res>
    extends _$CountryEventCopyWithImpl<$Res>
    implements $InitialCountryEventCopyWith<$Res> {
  _$InitialCountryEventCopyWithImpl(
      InitialCountryEvent _value, $Res Function(InitialCountryEvent) _then)
      : super(_value, (v) => _then(v as InitialCountryEvent));

  @override
  InitialCountryEvent get _value => super._value as InitialCountryEvent;
}

/// @nodoc

class _$InitialCountryEvent implements InitialCountryEvent {
  const _$InitialCountryEvent();

  @override
  String toString() {
    return 'CountryEvent.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InitialCountryEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Country country) remove,
    required TResult Function(Country country) selected,
    required TResult Function(String input) inputAccepted,
    required TResult Function(String input) keyboardInput,
    required TResult Function(String input) keyboardSubmit,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Country country)? remove,
    TResult Function(Country country)? selected,
    TResult Function(String input)? inputAccepted,
    TResult Function(String input)? keyboardInput,
    TResult Function(String input)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialCountryEvent value) init,
    required TResult Function(RemoveCountryEvent value) remove,
    required TResult Function(SelectedCountryEvent value) selected,
    required TResult Function(InputAcceptedCountryEvent value) inputAccepted,
    required TResult Function(KeyboardInputCountryEvent value) keyboardInput,
    required TResult Function(KeyboardSubmitCountryEvent value) keyboardSubmit,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialCountryEvent value)? init,
    TResult Function(RemoveCountryEvent value)? remove,
    TResult Function(SelectedCountryEvent value)? selected,
    TResult Function(InputAcceptedCountryEvent value)? inputAccepted,
    TResult Function(KeyboardInputCountryEvent value)? keyboardInput,
    TResult Function(KeyboardSubmitCountryEvent value)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class InitialCountryEvent implements CountryEvent {
  const factory InitialCountryEvent() = _$InitialCountryEvent;
}

/// @nodoc
abstract class $RemoveCountryEventCopyWith<$Res> {
  factory $RemoveCountryEventCopyWith(
          RemoveCountryEvent value, $Res Function(RemoveCountryEvent) then) =
      _$RemoveCountryEventCopyWithImpl<$Res>;
  $Res call({Country country});
}

/// @nodoc
class _$RemoveCountryEventCopyWithImpl<$Res>
    extends _$CountryEventCopyWithImpl<$Res>
    implements $RemoveCountryEventCopyWith<$Res> {
  _$RemoveCountryEventCopyWithImpl(
      RemoveCountryEvent _value, $Res Function(RemoveCountryEvent) _then)
      : super(_value, (v) => _then(v as RemoveCountryEvent));

  @override
  RemoveCountryEvent get _value => super._value as RemoveCountryEvent;

  @override
  $Res call({
    Object? country = freezed,
  }) {
    return _then(RemoveCountryEvent(
      country == freezed
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as Country,
    ));
  }
}

/// @nodoc

class _$RemoveCountryEvent implements RemoveCountryEvent {
  const _$RemoveCountryEvent(this.country);

  @override
  final Country country;

  @override
  String toString() {
    return 'CountryEvent.remove(country: $country)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RemoveCountryEvent &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(country);

  @JsonKey(ignore: true)
  @override
  $RemoveCountryEventCopyWith<RemoveCountryEvent> get copyWith =>
      _$RemoveCountryEventCopyWithImpl<RemoveCountryEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Country country) remove,
    required TResult Function(Country country) selected,
    required TResult Function(String input) inputAccepted,
    required TResult Function(String input) keyboardInput,
    required TResult Function(String input) keyboardSubmit,
  }) {
    return remove(country);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Country country)? remove,
    TResult Function(Country country)? selected,
    TResult Function(String input)? inputAccepted,
    TResult Function(String input)? keyboardInput,
    TResult Function(String input)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(country);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialCountryEvent value) init,
    required TResult Function(RemoveCountryEvent value) remove,
    required TResult Function(SelectedCountryEvent value) selected,
    required TResult Function(InputAcceptedCountryEvent value) inputAccepted,
    required TResult Function(KeyboardInputCountryEvent value) keyboardInput,
    required TResult Function(KeyboardSubmitCountryEvent value) keyboardSubmit,
  }) {
    return remove(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialCountryEvent value)? init,
    TResult Function(RemoveCountryEvent value)? remove,
    TResult Function(SelectedCountryEvent value)? selected,
    TResult Function(InputAcceptedCountryEvent value)? inputAccepted,
    TResult Function(KeyboardInputCountryEvent value)? keyboardInput,
    TResult Function(KeyboardSubmitCountryEvent value)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(this);
    }
    return orElse();
  }
}

abstract class RemoveCountryEvent implements CountryEvent {
  const factory RemoveCountryEvent(Country country) = _$RemoveCountryEvent;

  Country get country => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RemoveCountryEventCopyWith<RemoveCountryEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SelectedCountryEventCopyWith<$Res> {
  factory $SelectedCountryEventCopyWith(SelectedCountryEvent value,
          $Res Function(SelectedCountryEvent) then) =
      _$SelectedCountryEventCopyWithImpl<$Res>;
  $Res call({Country country});
}

/// @nodoc
class _$SelectedCountryEventCopyWithImpl<$Res>
    extends _$CountryEventCopyWithImpl<$Res>
    implements $SelectedCountryEventCopyWith<$Res> {
  _$SelectedCountryEventCopyWithImpl(
      SelectedCountryEvent _value, $Res Function(SelectedCountryEvent) _then)
      : super(_value, (v) => _then(v as SelectedCountryEvent));

  @override
  SelectedCountryEvent get _value => super._value as SelectedCountryEvent;

  @override
  $Res call({
    Object? country = freezed,
  }) {
    return _then(SelectedCountryEvent(
      country == freezed
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as Country,
    ));
  }
}

/// @nodoc

class _$SelectedCountryEvent implements SelectedCountryEvent {
  const _$SelectedCountryEvent(this.country);

  @override
  final Country country;

  @override
  String toString() {
    return 'CountryEvent.selected(country: $country)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SelectedCountryEvent &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(country);

  @JsonKey(ignore: true)
  @override
  $SelectedCountryEventCopyWith<SelectedCountryEvent> get copyWith =>
      _$SelectedCountryEventCopyWithImpl<SelectedCountryEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Country country) remove,
    required TResult Function(Country country) selected,
    required TResult Function(String input) inputAccepted,
    required TResult Function(String input) keyboardInput,
    required TResult Function(String input) keyboardSubmit,
  }) {
    return selected(country);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Country country)? remove,
    TResult Function(Country country)? selected,
    TResult Function(String input)? inputAccepted,
    TResult Function(String input)? keyboardInput,
    TResult Function(String input)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (selected != null) {
      return selected(country);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialCountryEvent value) init,
    required TResult Function(RemoveCountryEvent value) remove,
    required TResult Function(SelectedCountryEvent value) selected,
    required TResult Function(InputAcceptedCountryEvent value) inputAccepted,
    required TResult Function(KeyboardInputCountryEvent value) keyboardInput,
    required TResult Function(KeyboardSubmitCountryEvent value) keyboardSubmit,
  }) {
    return selected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialCountryEvent value)? init,
    TResult Function(RemoveCountryEvent value)? remove,
    TResult Function(SelectedCountryEvent value)? selected,
    TResult Function(InputAcceptedCountryEvent value)? inputAccepted,
    TResult Function(KeyboardInputCountryEvent value)? keyboardInput,
    TResult Function(KeyboardSubmitCountryEvent value)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (selected != null) {
      return selected(this);
    }
    return orElse();
  }
}

abstract class SelectedCountryEvent implements CountryEvent {
  const factory SelectedCountryEvent(Country country) = _$SelectedCountryEvent;

  Country get country => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SelectedCountryEventCopyWith<SelectedCountryEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InputAcceptedCountryEventCopyWith<$Res> {
  factory $InputAcceptedCountryEventCopyWith(InputAcceptedCountryEvent value,
          $Res Function(InputAcceptedCountryEvent) then) =
      _$InputAcceptedCountryEventCopyWithImpl<$Res>;
  $Res call({String input});
}

/// @nodoc
class _$InputAcceptedCountryEventCopyWithImpl<$Res>
    extends _$CountryEventCopyWithImpl<$Res>
    implements $InputAcceptedCountryEventCopyWith<$Res> {
  _$InputAcceptedCountryEventCopyWithImpl(InputAcceptedCountryEvent _value,
      $Res Function(InputAcceptedCountryEvent) _then)
      : super(_value, (v) => _then(v as InputAcceptedCountryEvent));

  @override
  InputAcceptedCountryEvent get _value =>
      super._value as InputAcceptedCountryEvent;

  @override
  $Res call({
    Object? input = freezed,
  }) {
    return _then(InputAcceptedCountryEvent(
      input == freezed
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InputAcceptedCountryEvent implements InputAcceptedCountryEvent {
  const _$InputAcceptedCountryEvent(this.input);

  @override
  final String input;

  @override
  String toString() {
    return 'CountryEvent.inputAccepted(input: $input)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InputAcceptedCountryEvent &&
            (identical(other.input, input) ||
                const DeepCollectionEquality().equals(other.input, input)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(input);

  @JsonKey(ignore: true)
  @override
  $InputAcceptedCountryEventCopyWith<InputAcceptedCountryEvent> get copyWith =>
      _$InputAcceptedCountryEventCopyWithImpl<InputAcceptedCountryEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Country country) remove,
    required TResult Function(Country country) selected,
    required TResult Function(String input) inputAccepted,
    required TResult Function(String input) keyboardInput,
    required TResult Function(String input) keyboardSubmit,
  }) {
    return inputAccepted(input);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Country country)? remove,
    TResult Function(Country country)? selected,
    TResult Function(String input)? inputAccepted,
    TResult Function(String input)? keyboardInput,
    TResult Function(String input)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (inputAccepted != null) {
      return inputAccepted(input);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialCountryEvent value) init,
    required TResult Function(RemoveCountryEvent value) remove,
    required TResult Function(SelectedCountryEvent value) selected,
    required TResult Function(InputAcceptedCountryEvent value) inputAccepted,
    required TResult Function(KeyboardInputCountryEvent value) keyboardInput,
    required TResult Function(KeyboardSubmitCountryEvent value) keyboardSubmit,
  }) {
    return inputAccepted(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialCountryEvent value)? init,
    TResult Function(RemoveCountryEvent value)? remove,
    TResult Function(SelectedCountryEvent value)? selected,
    TResult Function(InputAcceptedCountryEvent value)? inputAccepted,
    TResult Function(KeyboardInputCountryEvent value)? keyboardInput,
    TResult Function(KeyboardSubmitCountryEvent value)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (inputAccepted != null) {
      return inputAccepted(this);
    }
    return orElse();
  }
}

abstract class InputAcceptedCountryEvent implements CountryEvent {
  const factory InputAcceptedCountryEvent(String input) =
      _$InputAcceptedCountryEvent;

  String get input => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InputAcceptedCountryEventCopyWith<InputAcceptedCountryEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KeyboardInputCountryEventCopyWith<$Res> {
  factory $KeyboardInputCountryEventCopyWith(KeyboardInputCountryEvent value,
          $Res Function(KeyboardInputCountryEvent) then) =
      _$KeyboardInputCountryEventCopyWithImpl<$Res>;
  $Res call({String input});
}

/// @nodoc
class _$KeyboardInputCountryEventCopyWithImpl<$Res>
    extends _$CountryEventCopyWithImpl<$Res>
    implements $KeyboardInputCountryEventCopyWith<$Res> {
  _$KeyboardInputCountryEventCopyWithImpl(KeyboardInputCountryEvent _value,
      $Res Function(KeyboardInputCountryEvent) _then)
      : super(_value, (v) => _then(v as KeyboardInputCountryEvent));

  @override
  KeyboardInputCountryEvent get _value =>
      super._value as KeyboardInputCountryEvent;

  @override
  $Res call({
    Object? input = freezed,
  }) {
    return _then(KeyboardInputCountryEvent(
      input == freezed
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$KeyboardInputCountryEvent implements KeyboardInputCountryEvent {
  const _$KeyboardInputCountryEvent(this.input);

  @override
  final String input;

  @override
  String toString() {
    return 'CountryEvent.keyboardInput(input: $input)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is KeyboardInputCountryEvent &&
            (identical(other.input, input) ||
                const DeepCollectionEquality().equals(other.input, input)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(input);

  @JsonKey(ignore: true)
  @override
  $KeyboardInputCountryEventCopyWith<KeyboardInputCountryEvent> get copyWith =>
      _$KeyboardInputCountryEventCopyWithImpl<KeyboardInputCountryEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Country country) remove,
    required TResult Function(Country country) selected,
    required TResult Function(String input) inputAccepted,
    required TResult Function(String input) keyboardInput,
    required TResult Function(String input) keyboardSubmit,
  }) {
    return keyboardInput(input);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Country country)? remove,
    TResult Function(Country country)? selected,
    TResult Function(String input)? inputAccepted,
    TResult Function(String input)? keyboardInput,
    TResult Function(String input)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (keyboardInput != null) {
      return keyboardInput(input);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialCountryEvent value) init,
    required TResult Function(RemoveCountryEvent value) remove,
    required TResult Function(SelectedCountryEvent value) selected,
    required TResult Function(InputAcceptedCountryEvent value) inputAccepted,
    required TResult Function(KeyboardInputCountryEvent value) keyboardInput,
    required TResult Function(KeyboardSubmitCountryEvent value) keyboardSubmit,
  }) {
    return keyboardInput(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialCountryEvent value)? init,
    TResult Function(RemoveCountryEvent value)? remove,
    TResult Function(SelectedCountryEvent value)? selected,
    TResult Function(InputAcceptedCountryEvent value)? inputAccepted,
    TResult Function(KeyboardInputCountryEvent value)? keyboardInput,
    TResult Function(KeyboardSubmitCountryEvent value)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (keyboardInput != null) {
      return keyboardInput(this);
    }
    return orElse();
  }
}

abstract class KeyboardInputCountryEvent implements CountryEvent {
  const factory KeyboardInputCountryEvent(String input) =
      _$KeyboardInputCountryEvent;

  String get input => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $KeyboardInputCountryEventCopyWith<KeyboardInputCountryEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KeyboardSubmitCountryEventCopyWith<$Res> {
  factory $KeyboardSubmitCountryEventCopyWith(KeyboardSubmitCountryEvent value,
          $Res Function(KeyboardSubmitCountryEvent) then) =
      _$KeyboardSubmitCountryEventCopyWithImpl<$Res>;
  $Res call({String input});
}

/// @nodoc
class _$KeyboardSubmitCountryEventCopyWithImpl<$Res>
    extends _$CountryEventCopyWithImpl<$Res>
    implements $KeyboardSubmitCountryEventCopyWith<$Res> {
  _$KeyboardSubmitCountryEventCopyWithImpl(KeyboardSubmitCountryEvent _value,
      $Res Function(KeyboardSubmitCountryEvent) _then)
      : super(_value, (v) => _then(v as KeyboardSubmitCountryEvent));

  @override
  KeyboardSubmitCountryEvent get _value =>
      super._value as KeyboardSubmitCountryEvent;

  @override
  $Res call({
    Object? input = freezed,
  }) {
    return _then(KeyboardSubmitCountryEvent(
      input == freezed
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$KeyboardSubmitCountryEvent implements KeyboardSubmitCountryEvent {
  const _$KeyboardSubmitCountryEvent(this.input);

  @override
  final String input;

  @override
  String toString() {
    return 'CountryEvent.keyboardSubmit(input: $input)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is KeyboardSubmitCountryEvent &&
            (identical(other.input, input) ||
                const DeepCollectionEquality().equals(other.input, input)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(input);

  @JsonKey(ignore: true)
  @override
  $KeyboardSubmitCountryEventCopyWith<KeyboardSubmitCountryEvent>
      get copyWith =>
          _$KeyboardSubmitCountryEventCopyWithImpl<KeyboardSubmitCountryEvent>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(Country country) remove,
    required TResult Function(Country country) selected,
    required TResult Function(String input) inputAccepted,
    required TResult Function(String input) keyboardInput,
    required TResult Function(String input) keyboardSubmit,
  }) {
    return keyboardSubmit(input);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(Country country)? remove,
    TResult Function(Country country)? selected,
    TResult Function(String input)? inputAccepted,
    TResult Function(String input)? keyboardInput,
    TResult Function(String input)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (keyboardSubmit != null) {
      return keyboardSubmit(input);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialCountryEvent value) init,
    required TResult Function(RemoveCountryEvent value) remove,
    required TResult Function(SelectedCountryEvent value) selected,
    required TResult Function(InputAcceptedCountryEvent value) inputAccepted,
    required TResult Function(KeyboardInputCountryEvent value) keyboardInput,
    required TResult Function(KeyboardSubmitCountryEvent value) keyboardSubmit,
  }) {
    return keyboardSubmit(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialCountryEvent value)? init,
    TResult Function(RemoveCountryEvent value)? remove,
    TResult Function(SelectedCountryEvent value)? selected,
    TResult Function(InputAcceptedCountryEvent value)? inputAccepted,
    TResult Function(KeyboardInputCountryEvent value)? keyboardInput,
    TResult Function(KeyboardSubmitCountryEvent value)? keyboardSubmit,
    required TResult orElse(),
  }) {
    if (keyboardSubmit != null) {
      return keyboardSubmit(this);
    }
    return orElse();
  }
}

abstract class KeyboardSubmitCountryEvent implements CountryEvent {
  const factory KeyboardSubmitCountryEvent(String input) =
      _$KeyboardSubmitCountryEvent;

  String get input => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $KeyboardSubmitCountryEventCopyWith<KeyboardSubmitCountryEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$CountryStateTearOff {
  const _$CountryStateTearOff();

  LoadingCountryState loading() {
    return const LoadingCountryState();
  }

  LoadedCountryState loaded({required List<Country> countries}) {
    return LoadedCountryState(
      countries: countries,
    );
  }

  ErrorCountryState error({required String errorMessage}) {
    return ErrorCountryState(
      errorMessage: errorMessage,
    );
  }
}

/// @nodoc
const $CountryState = _$CountryStateTearOff();

/// @nodoc
mixin _$CountryState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<Country> countries) loaded,
    required TResult Function(String errorMessage) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<Country> countries)? loaded,
    TResult Function(String errorMessage)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingCountryState value) loading,
    required TResult Function(LoadedCountryState value) loaded,
    required TResult Function(ErrorCountryState value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingCountryState value)? loading,
    TResult Function(LoadedCountryState value)? loaded,
    TResult Function(ErrorCountryState value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CountryStateCopyWith<$Res> {
  factory $CountryStateCopyWith(
          CountryState value, $Res Function(CountryState) then) =
      _$CountryStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$CountryStateCopyWithImpl<$Res> implements $CountryStateCopyWith<$Res> {
  _$CountryStateCopyWithImpl(this._value, this._then);

  final CountryState _value;
  // ignore: unused_field
  final $Res Function(CountryState) _then;
}

/// @nodoc
abstract class $LoadingCountryStateCopyWith<$Res> {
  factory $LoadingCountryStateCopyWith(
          LoadingCountryState value, $Res Function(LoadingCountryState) then) =
      _$LoadingCountryStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoadingCountryStateCopyWithImpl<$Res>
    extends _$CountryStateCopyWithImpl<$Res>
    implements $LoadingCountryStateCopyWith<$Res> {
  _$LoadingCountryStateCopyWithImpl(
      LoadingCountryState _value, $Res Function(LoadingCountryState) _then)
      : super(_value, (v) => _then(v as LoadingCountryState));

  @override
  LoadingCountryState get _value => super._value as LoadingCountryState;
}

/// @nodoc

class _$LoadingCountryState implements LoadingCountryState {
  const _$LoadingCountryState();

  @override
  String toString() {
    return 'CountryState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoadingCountryState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<Country> countries) loaded,
    required TResult Function(String errorMessage) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<Country> countries)? loaded,
    TResult Function(String errorMessage)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingCountryState value) loading,
    required TResult Function(LoadedCountryState value) loaded,
    required TResult Function(ErrorCountryState value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingCountryState value)? loading,
    TResult Function(LoadedCountryState value)? loaded,
    TResult Function(ErrorCountryState value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingCountryState implements CountryState {
  const factory LoadingCountryState() = _$LoadingCountryState;
}

/// @nodoc
abstract class $LoadedCountryStateCopyWith<$Res> {
  factory $LoadedCountryStateCopyWith(
          LoadedCountryState value, $Res Function(LoadedCountryState) then) =
      _$LoadedCountryStateCopyWithImpl<$Res>;
  $Res call({List<Country> countries});
}

/// @nodoc
class _$LoadedCountryStateCopyWithImpl<$Res>
    extends _$CountryStateCopyWithImpl<$Res>
    implements $LoadedCountryStateCopyWith<$Res> {
  _$LoadedCountryStateCopyWithImpl(
      LoadedCountryState _value, $Res Function(LoadedCountryState) _then)
      : super(_value, (v) => _then(v as LoadedCountryState));

  @override
  LoadedCountryState get _value => super._value as LoadedCountryState;

  @override
  $Res call({
    Object? countries = freezed,
  }) {
    return _then(LoadedCountryState(
      countries: countries == freezed
          ? _value.countries
          : countries // ignore: cast_nullable_to_non_nullable
              as List<Country>,
    ));
  }
}

/// @nodoc

class _$LoadedCountryState implements LoadedCountryState {
  const _$LoadedCountryState({required this.countries});

  @override
  final List<Country> countries;

  @override
  String toString() {
    return 'CountryState.loaded(countries: $countries)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LoadedCountryState &&
            (identical(other.countries, countries) ||
                const DeepCollectionEquality()
                    .equals(other.countries, countries)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(countries);

  @JsonKey(ignore: true)
  @override
  $LoadedCountryStateCopyWith<LoadedCountryState> get copyWith =>
      _$LoadedCountryStateCopyWithImpl<LoadedCountryState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<Country> countries) loaded,
    required TResult Function(String errorMessage) error,
  }) {
    return loaded(countries);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<Country> countries)? loaded,
    TResult Function(String errorMessage)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(countries);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingCountryState value) loading,
    required TResult Function(LoadedCountryState value) loaded,
    required TResult Function(ErrorCountryState value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingCountryState value)? loading,
    TResult Function(LoadedCountryState value)? loaded,
    TResult Function(ErrorCountryState value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class LoadedCountryState implements CountryState {
  const factory LoadedCountryState({required List<Country> countries}) =
      _$LoadedCountryState;

  List<Country> get countries => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LoadedCountryStateCopyWith<LoadedCountryState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ErrorCountryStateCopyWith<$Res> {
  factory $ErrorCountryStateCopyWith(
          ErrorCountryState value, $Res Function(ErrorCountryState) then) =
      _$ErrorCountryStateCopyWithImpl<$Res>;
  $Res call({String errorMessage});
}

/// @nodoc
class _$ErrorCountryStateCopyWithImpl<$Res>
    extends _$CountryStateCopyWithImpl<$Res>
    implements $ErrorCountryStateCopyWith<$Res> {
  _$ErrorCountryStateCopyWithImpl(
      ErrorCountryState _value, $Res Function(ErrorCountryState) _then)
      : super(_value, (v) => _then(v as ErrorCountryState));

  @override
  ErrorCountryState get _value => super._value as ErrorCountryState;

  @override
  $Res call({
    Object? errorMessage = freezed,
  }) {
    return _then(ErrorCountryState(
      errorMessage: errorMessage == freezed
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorCountryState implements ErrorCountryState {
  const _$ErrorCountryState({required this.errorMessage});

  @override
  final String errorMessage;

  @override
  String toString() {
    return 'CountryState.error(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ErrorCountryState &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(errorMessage);

  @JsonKey(ignore: true)
  @override
  $ErrorCountryStateCopyWith<ErrorCountryState> get copyWith =>
      _$ErrorCountryStateCopyWithImpl<ErrorCountryState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<Country> countries) loaded,
    required TResult Function(String errorMessage) error,
  }) {
    return error(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<Country> countries)? loaded,
    TResult Function(String errorMessage)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadingCountryState value) loading,
    required TResult Function(LoadedCountryState value) loaded,
    required TResult Function(ErrorCountryState value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadingCountryState value)? loading,
    TResult Function(LoadedCountryState value)? loaded,
    TResult Function(ErrorCountryState value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ErrorCountryState implements CountryState {
  const factory ErrorCountryState({required String errorMessage}) =
      _$ErrorCountryState;

  String get errorMessage => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ErrorCountryStateCopyWith<ErrorCountryState> get copyWith =>
      throw _privateConstructorUsedError;
}
